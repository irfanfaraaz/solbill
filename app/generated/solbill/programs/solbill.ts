/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertIsInstructionWithAccounts,
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type Instruction,
  type InstructionWithData,
  type ReadonlyUint8Array,
} from "@solana/kit";
import {
  parseCancelSubscriptionInstruction,
  parseChangePlanInstruction,
  parseCollectPaymentInstruction,
  parseCreatePlanInstruction,
  parseCreateSubscriptionInstruction,
  parseExpireSubscriptionInstruction,
  parseInitializeServiceInstruction,
  parseUpdatePlanInstruction,
  type ParsedCancelSubscriptionInstruction,
  type ParsedChangePlanInstruction,
  type ParsedCollectPaymentInstruction,
  type ParsedCreatePlanInstruction,
  type ParsedCreateSubscriptionInstruction,
  type ParsedExpireSubscriptionInstruction,
  type ParsedInitializeServiceInstruction,
  type ParsedUpdatePlanInstruction,
} from "../instructions";

export const SOLBILL_PROGRAM_ADDRESS =
  "AK2xA7SHMKPqvQEirLUNf4gRQjzpQZT3q6v3d62kLyzx" as Address<"AK2xA7SHMKPqvQEirLUNf4gRQjzpQZT3q6v3d62kLyzx">;

export enum SolbillAccount {
  PlanAccount,
  ServiceAccount,
  SubscriptionAccount,
}

export function identifySolbillAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): SolbillAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([48, 175, 200, 230, 173, 125, 152, 245]),
      ),
      0,
    )
  ) {
    return SolbillAccount.PlanAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([72, 33, 73, 146, 208, 186, 107, 192]),
      ),
      0,
    )
  ) {
    return SolbillAccount.ServiceAccount;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([247, 1, 6, 72, 172, 66, 24, 128]),
      ),
      0,
    )
  ) {
    return SolbillAccount.SubscriptionAccount;
  }
  throw new Error(
    "The provided account could not be identified as a solbill account.",
  );
}

export enum SolbillInstruction {
  CancelSubscription,
  ChangePlan,
  CollectPayment,
  CreatePlan,
  CreateSubscription,
  ExpireSubscription,
  InitializeService,
  UpdatePlan,
}

export function identifySolbillInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): SolbillInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([60, 139, 189, 242, 191, 208, 143, 18]),
      ),
      0,
    )
  ) {
    return SolbillInstruction.CancelSubscription;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([75, 206, 141, 79, 34, 245, 125, 189]),
      ),
      0,
    )
  ) {
    return SolbillInstruction.ChangePlan;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([180, 221, 16, 160, 45, 216, 91, 97]),
      ),
      0,
    )
  ) {
    return SolbillInstruction.CollectPayment;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([77, 43, 141, 254, 212, 118, 41, 186]),
      ),
      0,
    )
  ) {
    return SolbillInstruction.CreatePlan;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([65, 71, 10, 60, 249, 82, 197, 12]),
      ),
      0,
    )
  ) {
    return SolbillInstruction.CreateSubscription;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([67, 52, 139, 195, 202, 161, 207, 35]),
      ),
      0,
    )
  ) {
    return SolbillInstruction.ExpireSubscription;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([201, 217, 126, 168, 40, 110, 122, 89]),
      ),
      0,
    )
  ) {
    return SolbillInstruction.InitializeService;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([119, 112, 58, 60, 76, 205, 1, 100]),
      ),
      0,
    )
  ) {
    return SolbillInstruction.UpdatePlan;
  }
  throw new Error(
    "The provided instruction could not be identified as a solbill instruction.",
  );
}

export type ParsedSolbillInstruction<
  TProgram extends string = "AK2xA7SHMKPqvQEirLUNf4gRQjzpQZT3q6v3d62kLyzx",
> =
  | ({
      instructionType: SolbillInstruction.CancelSubscription;
    } & ParsedCancelSubscriptionInstruction<TProgram>)
  | ({
      instructionType: SolbillInstruction.ChangePlan;
    } & ParsedChangePlanInstruction<TProgram>)
  | ({
      instructionType: SolbillInstruction.CollectPayment;
    } & ParsedCollectPaymentInstruction<TProgram>)
  | ({
      instructionType: SolbillInstruction.CreatePlan;
    } & ParsedCreatePlanInstruction<TProgram>)
  | ({
      instructionType: SolbillInstruction.CreateSubscription;
    } & ParsedCreateSubscriptionInstruction<TProgram>)
  | ({
      instructionType: SolbillInstruction.ExpireSubscription;
    } & ParsedExpireSubscriptionInstruction<TProgram>)
  | ({
      instructionType: SolbillInstruction.InitializeService;
    } & ParsedInitializeServiceInstruction<TProgram>)
  | ({
      instructionType: SolbillInstruction.UpdatePlan;
    } & ParsedUpdatePlanInstruction<TProgram>);

export function parseSolbillInstruction<TProgram extends string>(
  instruction: Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array>,
): ParsedSolbillInstruction<TProgram> {
  const instructionType = identifySolbillInstruction(instruction);
  switch (instructionType) {
    case SolbillInstruction.CancelSubscription: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: SolbillInstruction.CancelSubscription,
        ...parseCancelSubscriptionInstruction(instruction),
      };
    }
    case SolbillInstruction.ChangePlan: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: SolbillInstruction.ChangePlan,
        ...parseChangePlanInstruction(instruction),
      };
    }
    case SolbillInstruction.CollectPayment: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: SolbillInstruction.CollectPayment,
        ...parseCollectPaymentInstruction(instruction),
      };
    }
    case SolbillInstruction.CreatePlan: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: SolbillInstruction.CreatePlan,
        ...parseCreatePlanInstruction(instruction),
      };
    }
    case SolbillInstruction.CreateSubscription: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: SolbillInstruction.CreateSubscription,
        ...parseCreateSubscriptionInstruction(instruction),
      };
    }
    case SolbillInstruction.ExpireSubscription: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: SolbillInstruction.ExpireSubscription,
        ...parseExpireSubscriptionInstruction(instruction),
      };
    }
    case SolbillInstruction.InitializeService: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: SolbillInstruction.InitializeService,
        ...parseInitializeServiceInstruction(instruction),
      };
    }
    case SolbillInstruction.UpdatePlan: {
      assertIsInstructionWithAccounts(instruction);
      return {
        instructionType: SolbillInstruction.UpdatePlan,
        ...parseUpdatePlanInstruction(instruction),
      };
    }
    default:
      throw new Error(
        `Unrecognized instruction type: ${instructionType as string}`,
      );
  }
}
